# Event Loop <!-- omit in toc -->

> Author: tinfengyee
> Date: 2022-11-25 01:17:59
> LastEditTime: 2022-11-25 01:18:00
> Description: NO Desc

## 简答

在这之前，强调一遍 `Event Loop`。

`Event Loop` 执行顺序：

1. 一开始整个脚本 `script` 作为一个宏任务执行
2. 执行过程中，**同步代码** 直接执行，**宏任务** 进入宏任务队列，**微任务** 进入微任务队列。
3. 当前宏任务执行完出队，检查微任务列表，有则依次执行，直到全部执行完毕。
4. 执行浏览器 UI 线程的渲染工作。
5. 检查是否有 `Web Worker` 任务，有则执行。
6. 执行完本轮的宏任务，回到步骤 2，依次循环，直到宏任务和微任务队列为空。

**微任务** 包括：

* `MutationObserver`
* `Promise.then()/catch()`
* 以 `Promise` 为基础开发的其他技术，例如 `fetch API`
* V8 的垃圾回收过程
* Node 独有的 `process.nextTick`

**宏任务** 包括：

* `script`
* `setTimeout`
* `setInterval`
* `setImmediate`
* `I/O`
* `UI rendering`

## 前言

《前端进阶系列-js引擎的执行过程(二)》

本文主要分析js引擎执行的第三个阶段--**执行阶段**，在分析之前我们先思考以下两个问题：

> js是单线程的，为了避免代码解析阻塞使用了异步执行，那么它的异步执行机制是怎么样的？

通过事件循环（Event Loop），理解了事件循环的原理就理解了js的异步执行机制，本文主要介绍。

> js是单线程的，那么是否代表参与js执行过程的线程就只有一个？

不是的，会有四个线程参与该过程，但是永远只有JS引擎线程在执行JS脚本程序，其他的三个线程只协助，不参与代码解析与执行。参与js执行过程的线程分别是：

 - **JS引擎线程**： 也称为JS内核，负责解析执行Javascript脚本程序的主线程（例如V8引擎）

 - **事件触发线程**： 归属于浏览器内核进程，不受JS引擎线程控制。主要用于控制事件（例如鼠标，键盘等事件），当该事件被触发时候，事件触发线程就会把该事件的处理函数推进**事件队列**，等待JS引擎线程执行

- **定时器触发线程**：主要控制计时器setInterval和延时器setTimeout，用于定时器的计时，计时完毕，满足定时器的触发条件，则将定时器的处理函数推进事件队列中，等待JS引擎线程执行。
  注：W3C在HTML标准中规定setTimeout低于4ms的时间间隔算为4ms。

- **HTTP异步请求线程**：通过XMLHttpRequest连接后，通过浏览器新开的一个线程，监控readyState状态变更时，如果设置了该状态的回调函数，则将该状态的处理函数推进事件队列中，等待JS引擎线程执行。
  注：浏览器对通一域名请求的并发连接数是有限制的，Chrome和Firefox限制数为6个，ie8则为10个。

## 宏任务和微任务

任务队列其实不止一种，根据任务种类的不同，可以分为**微任务（micro task）队列**和**宏任务（macro task）队列**。常见的任务如下：

- **宏任务：** script( 整体代码)、setTimeout、setInterval、I/O、UI 交互事件、setImmediate(Node.js 环境)
- **微任务：** Promise、MutaionObserver、process.nextTick(Node.js 环境)；

## 循环过程

(始执行的代码，实际上也是宏任务)

总结：永远只有JS引擎线程在执行JS脚本程序，其他三个线程只负责将满足触发条件的处理函数推进事件队列，等待JS引擎线程执行。

在宏任务中执行的任务有两种，分别是**同步任务**和**异步任务**，因为异步任务会在满足触发条件时才会推进任务队列（task queue），然后等待主线程上的任务执行完毕，再读取任务队列中的任务事件，最后推进主线程执行，所以这里将<u>异步任务即任务队列看作是新的宏任务</u>。执行的过程如上图所示：

1. 执行宏任务中**同步任务**，执行结束；

2. 检查是否存在可执行的**微任务**，有的话执行所有微任务，然后读取任务队列的任务事件，推进主线程形成新的宏任务；没有的话则读取任务队列的任务事件，推进主线程形成新的宏任务

3. 执行**新宏任务**的事件任务，再检查是否存在可执行的微任务，如此不断的重复循环

> Eventloop 在处理宏任务和微任务的逻辑时的执行情况如下：
>
> 1. JavaScript 引擎首先从宏任务队列中取出第一个任务；
> 2. 执行完毕后，再将微任务中的所有任务取出，按照顺序分别全部执行（这里包括不仅指开始执行时队列里的微任务），如果在这一步过程中产生新的微任务，也需要执行，**也就是说在执行微任务过程中产生的新的微任务并不会推迟到下一个循环中执行，而是在当前的循环中继续执行。**
> 3. 然后再从宏任务队列中取下一个，执行完毕后，再次将 microtask queue 中的全部取出，循环往复，直到两个 queue 中的任务都取完。

## 为什么要将任务队列分为微任务和宏任务呢，他们之间的本质区别是什么呢？

JavaScript在遇到异步任务时，会将此任务交给其他线程来执行（比如遇到setTimeout任务，会交给定时器触发线程去执行，待计时结束，就会将定时器回调任务放入任务队列等待主线程来取出执行），主线程会继续执行后面的同步任务。

对于微任务，比如promise.then，当执行promise.then时，浏览器引擎不会将异步任务交给其他浏览器的线程去执行，而是将任务回调存在一个队列中，当执行栈中的任务执行完之后，就去执行promise.then所在的微任务队列。

所以，宏任务和微任务的本质区别如下：

- 微任务：不需要特定的异步线程去执行，没有明确的异步任务去执行，只有回调；
- 宏任务：需要特定的异步线程去执行，有明确的异步任务去执行，有回调；

## 参考资料

- [ ] [js引擎的执行过程（二）](https://heyingye.github.io/2018/03/26/js%E5%BC%95%E6%93%8E%E7%9A%84%E6%89%A7%E8%A1%8C%E8%BF%87%E7%A8%8B%EF%BC%88%E4%BA%8C%EF%BC%89/)

- [ ] [彻底搞懂JavaScript事件循环](https://juejin.cn/post/6992167223523541023)