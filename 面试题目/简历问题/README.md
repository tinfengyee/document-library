## 上传组件+压缩

[vue封装文件上传组件](https://juejin.cn/post/7131678686608097287)

[手写一个Vue版Upload组件](https://juejin.cn/post/6844904094667112461)

```js
//利用canvas绘制压缩的图片并生成新的图片
const context = canvas.getContext("2d");
context.drawImage(this, 0, 0, width, height);
canvas.toBlob(
  blob => {
    that.file = blob;
    that.upload(blob);
    that.$emit("on-change", blob, that.options);
  },
  "image/png",
  that.quality
);
```

## 接口请求数据的缓存实践

[「趣学前端」接口请求数据的缓存实践](https://developer.aliyun.com/article/1041320)

一、灵感来源
最近在做新需求开发的时候，我发现某些页面进入时需要加载4、5个接口，我检查这些接口，发现大部分是基础数据，比如省、市、区或者某些特定分类（比如商品分类）等。这个数据需要通过后端接口请求获取，然后将数据回显到前端页面，让用户找到自己想要查询的筛选项。
每次进入带有省份筛选条件的列表页面，为了支持用户可以按照某个省份进行筛选的操作，都会将省份接口请求一次，拿到全部的省份列表。其实省份数据更新的频率很低，于是我就想如果用数据缓存替代接口请求是不是也可以？
二、假设与求证
再开始设计功能之前，我找到后端的同事进行了确认，我们的省市区（周一问一下）除非有特殊情况，基本不会更新。于是为了保险，我将缓存设置为了会话缓存，没有设置持久缓存。其实持久缓存设置过期时间也可以，但是因为是功能优化，优化的前提是不能带来额外的问题，所以为了稳妥，我采用了会话缓存。

### 面试官: 如何让localStorage支持过期时间设置?

[面试官: 如何让localStorage支持过期时间设置?	](https://cloud.tencent.com/developer/article/1917589)

2. 中级解法
前端工程师在有一定的工作经验之后, 往往会去考虑工程化和复用性的问题, 并对数据结构有了一定的了解, 所以可能会有接下来的解法:

用localStorage存一份{key(键): expire(过期时间)}的映射表
重写localStorage API, 对方法进行二次封装

3. 高级解法
为了减少维护成本和空间占用, 并支持一定的灵活控制和容错能力, 我们又应该怎么做呢?

这里笔者想到了两种类似的方案:

将过期时间存到 key 中, 如 dooring|6000, 每次取值时通过分隔符“|”来将 key 和 expire 取出, 进行判断
将过期时间存到 value 中, 如 1.0.0|6000, 剩下的同1

## JWT生成token优势

https://blog.csdn.net/china_coding/article/details/125776022

**无状态**，我们的服务器不需要存储 Session 信息。这显然增加了系统的可用性和伸缩性，大大减轻了服务端的压力。不过，也正是由于 JWT 的无状态，也导致了它最大的缺点：**不可控！**

有效**避免了 [CSRF](https://so.csdn.net/so/search?q=CSRF&spm=1001.2101.3001.7020) 攻击**，**跨站请求伪造**

> **那为什么 JWT 不会存在这种问题呢？**一般情况下我们使用 JWT 的话，在我们登录成功获得 JWT 之后，一般会选择存放在 localStorage 中。前端的每一个请求后续都会附带上这个 JWT，整个过程压根不会涉及到 Cookie。

**适合移动端应用**
使用 Session 进行身份认证的话，需要保存一份信息在服务器端，而且这种方式会依赖到 Cookie(需要 Cookie 保存 SessionId)，所以不适合移动端。

但是，使用 JWT 进行身份认证就不会存在这种问题，因为只要 JWT 可以被客户端存储就能够使用，而且 JWT 还可以跨语言使用。

**单点登录友好**
使用 Session 进行身份认证的话，实现单点登录，需要我们把用户的 Session 信息保存在一台电脑上，并且还会遇到常见的 Cookie 跨域的问题。但是，使用 JWT 进行认证的话， JWT 被保存在客户端，不会存在这些问题。